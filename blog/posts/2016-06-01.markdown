---
author: patrick
date: 2016-06-01
id: "webpack-hot-reloading"
title: "Speeding up your Development Progress with Webpack and the React Components for OnsenUI"
category: tutorial
tags: tutorial, webpack, react, hot-reloading, onsenui
---

One of the great things about the [React](http:://reactjs.com) framework is that there are a lot of tools and libraries available. One of the most popular is the [React Hot Reloader](https://github.com/gaearon/react-hot-loader) by Dan Abramov, who also created [Redux](https://github.com/reactjs/redux). The React Hot Reloader enables the developer to make code changes and apply these changes to the application without loosing its state. In this tutorial we will build a small application step by step to demonstrate the the power of webpack and react and also show how OnsenUI users can benefit from it.

<!-- more -->

### Setting up the Environment

We will start with a blanck Node project.

```
npm init -f
```

This creates an empty project. If you get an error, make sure you have `node` and `npm` installed. A small [guide] can be found here `https://github.com/OnsenUI/OnsenUI/issues`. After initializing the project its time to install the dependencies. We will need the following packages:

* [React](https://facebook.github.io/react/): React is the libarary, which we will use for writing our javascript applications.
* [Babel](https://babeljs.io/): Babel transforms javascript and jsx files to javascript that can be executed in all browsers.
* [Webpack](https://webpack.github.io//): Webpack is a bundler, that puts all your javascript files into one big file. It also comes with many tools like the Development Server that support module reloading.
* [React Hot Reloader Plugin](https://github.com/gaearon/react-hot-loader): This is the plugin for webpack that allows to do hot reloading in react, so that after a file changes, the state of the components will still remain.
* [OnsenUI](https://onsen.io): OnsenUI is a UI library for mobile hybrid applications that provide many components like Navigators and Tabbar out of the box. It also has a nice [autostyling feature](https://onsen.io/blog/auto-style-app-onsen/.).

These plugins can all be installed with one command:

```
npm install --save babel-core babel-loader babel-preset-es2015 babel-preset-react babel-preset-stage-0 react-hot-loader@3.0.0-beta.1 webpack webpack-dev-server onsenui react react-dom react-onsenui

```

As a side node we use the beta version of React Reloader 3.0, since it is very stable and fixes a lot of issues that the previous version has.

### Configuring Webpack

Now that we have installed all the dependencies we need to configure [Webpack](https://webpack.github.io/). Webpack works like this: It first looks for a main javascript files and then searches through all the `require` and `import` statements and puts them together. To configure this process, webpack supports custom `loaders` and `plugins`.

A loader in webpack is a programm that transforms a file encountered by webpack to a javascript file that can be processed by webpack. With the power of loaders Webpack can import `json`, `css` and any kind of file type as long as there is a loader for it. For our purposes we will use the `babel-loader` to transform `jsx` to `js`.

A plugin is a program that allows to alter the inner processes of webpack. An example for this is the [HotModuleReplacementPlugin], that allows webpack to replace files during runtime. The list of plugins available can be found [here](https://github.com/webpack/docs/wiki/list-of-plugins).

Lets create our config file now:

```
var path = require('path');
var webpack = require('webpack');

module.exports = {
  devtool: 'eval',
  entry: [
    'react-hot-loader/patch',
    'webpack-dev-server/client?http://localhost:3000',
    'webpack/hot/only-dev-server',
    './src/index'
  ],
  output: {
    path: path.join(__dirname, 'dist'),
    filename: 'bundle.js',
    publicPath: '/static/'
  },
  plugins: [
    new webpack.HotModuleReplacementPlugin()
  ],

  devServer: {
    colors: true,
    historyApiFallback: true,
    inline: false,
    port: 3000,
    hot: true
  },

  module: {
    loaders: [{
      test: /\.js$/,
      loader: 'babel',
      query: {
        "presets": ["es2015", "stage-0", "react"],
        "plugins": ["react-hot-loader/babel"]
      },
      include: path.join(__dirname, 'src')
    }]
  }
};
```

The configuration file in webpack is a javascript file that exports a configuration. We configure things like the starting point of where webpack should start to bundle, the output file, the plugins, the general paramter configuration and the loaders. The most important part is the `babel` loader that uses the react-hot reloading plugin.

Now we need to add a script to start our server: In the package.json we replace the `script` value with.
  "scripts": {
    "start": "webpack-dev-server --progress"
  },
```

That is all for our webpack configration, now we can start coding.

# Our first example

This will allow us to start the server with `npm run`. However we need to first create a simple entry file.
Lets creat a simple html file:

```html
<!doctype html>
<html>
  <head>
    <title>Sample App</title>
    <link rel="stylesheet" type="text/css" href="./node_modules/onsenui/css/onsenui.css">
    <link rel="stylesheet" type="text/css" href="./node_modules/onsenui/css/onsen-css-components.css">
  </head>
  <body>
    <div id='root'>
    </div>
    <script src="/static/bundle.js"></script>
  </body>
</html>
```

We first create the entry file `src/index.js`:

```
import { AppContainer } from 'react-hot-loader';
import React from 'react';
import ReactDOM from 'react-dom';
import App from './App';

const rootElement = document.getElementById('root');
ReactDOM.render(
  <AppContainer>
    <App />
  </AppContainer>,
  rootElement
);

if (module.hot) {
  module.hot.accept('./App', () => {
    const NextApp = require('./App').default;
    ReactDOM.render(
      <AppContainer>
         <NextApp />
      </AppContainer>,
      rootElement
    );
  });
}
```
This might look a little bit overwhelming at first, but its a general pattern that we do not need to change. All the elements need to be wrapped in the AppContaineer and we write down the logic what should happen if hot reloading happens.

Now we can write our first simple application `App.js`.

```
import React from 'react';
import ReactDOM from 'react-dom';

export default class App extends React.Component {
  render() {
    return (
      <div>
      React test example.
      </div>
    );
  }
}
```

This example contains nothing more than a simple text.
Now we can start the server and see it in action. We first need to run `npm start` and open the browser at `http://localhost:3000/. We can change for example the text and add a new button, see the changes live here:


![Demonstration React reloader](/blog/content/images/2016/Jun/reloader.gif)


Here is what the end result looks like.

```
import React from 'react';
import ReactDOM from 'react-dom';

export default class App extends React.Component {
  render() {
    return (
      <div style={{fontSize: 20}}>
      React test example with hot reloading and font changes.
      </div>
    );
  }
}
```

All the code for this example can be found [here](https://github.com/philolo1/webpack-react-hot-reloading-sample).

# Hot reloading in Navigation

These changes are already nice, but the hot reloader can do much more. To demonstrate this, let us build a small mobile app using the [React Components for OnsenUI](https://onsen.io/v2/react.html).

We will create a simple App with two screen: The first screen will have a simple Input box and output the text written in that input. The second screen will just be some text. We put those screens together using the Navigator.

```
import 'onsenui'
import {Page, Navigator, Button, Input} from 'react-onsenui'

class PageOne extends React.Component {
  constructor(props) {
    super(props);
    this.state = {};
  }

  onChangeText(event) {
    this.setState({text: event.target.value});
  }

  pushPage() {
    this.props.navigator.pushPage({
      component: PageTwo
    });
  }

  render() {
    return (
      <Page>
        <div style={{padding: 20}}>
          <Input
            placeholder='Input field'
            style={{height: 20}}
            value={this.state.text}
            onChange={this.onChangeText.bind(this)} /> <br />
          <p>
            You typed {this.state.text}
          </p>
        </div>
      </Page>

    );
  }
};



class PageTwo extends React.Component {
  constructor(props) {
    super(props);
    this.state = {};
  }

  render() {
    return (
      <Page>
        <div style={{padding: 20}}>
          This is a second Page
        </div>
      </Page>

    );
  }
}

export default class App extends React.Component {
  constructor(props) {
    super(props);
  }

  renderPage(route, navigator) {
    const props = route.props || {};
    props.navigator = navigator;

    return React.createElement(route.component, props);
  }

  render() {
    return (
    <Navigator
      initialRoute={{
        component: PageOne
      }}
      renderPage={this.renderPage.bind(this)}
    />
    );
  }
}
```

To demonstrate hot reloading we will enter some text in the first page. Push the second Page and then add a pop button and save the file:
```
class PageTwo extends React.Component {
  constructor(props) {
    super(props);
    this.state = {};
  }

  render() {
    return (
      <Page>
        <div style={{padding: 20}}>
          This is a second Page
          <Button onClick={this.pushPage.bind(this)}> Push page </Button>
        </div>
      </Page>

    );
  }
}

```

Just with saving the file we will be able to use the pop button and still see the text that we had originally entered, the state of the application stays the same. Here is a life demonstration:

![Demonstration React reloader](/blog/content/images/2016/Jun/hot_reloader2.gif)


Again, the source code can be found at [here](https://github.com/philolo1/OnsenUI-Webpack-React-Hot-Reloading-Sample) to play with:

# Conclusion and reference

Hot Reloading is a very nice feature that can speed up the development process of your app. In the future, we plan to add the hot-reloader to the [Monaca CLI](https://monaca.io/debugger.html).
For those who want to learn more, we highly recommend the  [talk] (https://www.youtube.com/watch?v=xsSnOQynTHs) by Dan Abramov, the creator of this plugin and also of Redux, to get a general feeling about the development process. If any questions arise, we will be glad to answer your questions in our [Community](https://community.onsen.io/).
