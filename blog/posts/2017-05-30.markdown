---
author: adam
date: 2017-05-25
id: performance-features-in-webpack-2
title: "Performance features in webpack 2"
product: monaca
category: development
tags: webpack, monaca 
---

It's been a some time since release of webpack 2. Today I would like to explore some features introduced in it.
The focus of this blog post is mainly on features that help to control and improve the performance of your application. 
First is `tree shaking` feature which helps to reduce the size of your bundle by not including 
unused exports in it. Also, I will briefly describe code splitting feature and
how brand new `performance` configuration object can help you to use this feature properly.

## Tree Shaking
I would like to start from tree shaking feature which during transpiling process exclude
unused exports. This very simple example will illustrate the issue: 

```
// exports.js
exports function foo() {
  return 'used';
}

exports function bar() {
  return 'unused';
}
```
and then we want to importing `exports.js` in our file.

```
// application.js
import {foo} from './exports'
console.log(foo());
```

Old webpack by default would include both `foo` and 'bar' in minified file. 
New webpacki introduces alghoritm for excluding parts of code that are exported but not used in your application.   
In case presented above, `bar` function is not used in our file and in consequence it won't be part of minified bundle. 
This has a significant impact on output file size and can improve loading time of our application.
For further information about tree shaking check out blog post under 
this [link](http://2ality.com/2015/12/webpack-tree-shaking.html).


## Code splitting in webpack 

By default webpack is bundling your project in one monolith file. What does that mean
one file contain all third party libraries together with the code of our application. 
So each time you change something in the application the whole file has to be
uploaded again to the server and then downloaded by clients. It is very inefficient since 
third party libraries changes very rarely but from the other hand code of our application
changes frequently. But what if we could separate code that changes frequently from the one that supposes to change very rarely? 
Webpack from the beginning supports the feature called code splitting which allow us to do that.

Below I will briefly explain types of code splitting in webpack and then I will go to new introduced
`performance` configuration object which can give us more information about our splits.
<!--Configuring chunk name in import.-->

#### Vendor code splitting

These are third party libraries which content not change often. Since the content of these files
doesn't change frequently browser can load it once and then store it in the cache.
#### CSS splitting

We can split our css files into separate bundle files. That's allow loading application code in parallel 
with styles. In this case, we can as well take advantage of caching. 
#### On demand code splitting

This allows loading chunks that are only needed for the particular use case on programmer request.  
That way we can prioritize resource loading.
For more information check webpack [documentation](https://webpack.js.org/guides/code-splitting-async/).
## Code splitting and performance indicators

We need to remember that bundle size can have a significant impact on your application load time.
That's why putting and effort in proper configuration of code splitting is worthwhile.
You can use above features but how you actually check if code splitting configuration works as expected?
Discussion about [Webpack Performance Budgets](https://github.com/webpack/webpack/issues/3216) 
led to adding `performance` configuration object in webpack 2.
Thanks to it we can configure webpack to detect code splits that are above the expected size limit. 
In case if that happen we specify webpack behaviour by setting property `hints`. By default, 'hints' is set to `warning` which
 will display warning with information about large splits. We can can also set it to 'error' which will throw an error in case of exceeding size limit. Another properties we can specify are `maxEntryPointSize` and `maxAssetSize` I will explain them base on the
 example:

```
performance: {
  hints: "warning",
  maxEntrypointSize: 300000,
  maxAssetSize: 150000
}
```

By applying above configuration we will receive warning in case if size of our entry 
assets will be above 0.4 megabyte or if any of assets size emitted by webpack exceed 0.15 megabyte. 

Given numbers are just example and on [performance budget](http://www.performancebudget.io/) site you can 
check what kind of loading time you expect and base on that it will estimate proper bundle size for your application.
Having that number in your webpack configuration will help you to control size of your code splits
and in consequence avoid performance issues.

I hope that you find this post interesting. We would love to hear your feedback.
