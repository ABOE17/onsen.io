--
author: adam
date: 2017-05-25
id: vue-template-release
title: "Performance features in webpack 2"
product: monaca
category: announcement
tags: webpack 
---

It's been a some time since release of webpack 2. Today I would like to explore some features introduced in it.
The focus of this blog post is mainly on features that help to control and improve the performance of your application. 
First is `tree shaking` feature which helps to reduce the size of your bundle by not including 
unused exports in it. Also, I will briefly describe code splitting feature and
how brand new `performance` configuration object can help you to use this feature properly.

## Tree Shaking
I would like to start from tree shaking feature which during transpiling process exclude
unused exports. This very simple example will illustrate the issue: 

```
// exports.js
exports function foo() {
  return 'used';
}

exports function bar() {
  return 'unused';
}
```
and then we want to importing `exports.js` in our file.

```
// application.js
import {foo} from './exports'
console.log(foo());
```

Old webpack by default would include both `foo` and 'bar' in minified file. 
New webpacki introduces alghoritm for excluding parts of code that are exported but not used in your application.   
In case presented above, `bar` function is not used in our file and in consequence it won't be part of minified bundle. 
This has a significant impact on output file size and can improve loading time of our application.
For further information about tree shaking check out blog post under 
this [link](http://2ality.com/2015/12/webpack-tree-shaking.html).


## Code splitting in webpack 

There is one significant drawback of bundling your project in one monolith file.  
Our bundle will contain all third party libraries together with the code of our application. 
Because of that each time we will change something in the application the whole file has to be
uploaded again to the server and then downloaded by clients. But what if we could separate 
code that changes frequently from the one that supposes to change very rarely? 
Webpack from the beginning supports the feature called code splitting which let us do that. 

Below I will briefly explain types of code splitting in webpack and then I will go feature introduced on top of 
in webpack 2 release `performance` configuration object.
<!--Configuring chunk name in import.-->

#### Vendor code splitting

These are third party libraries which content not change often. Since the content of these files
doesn't change frequently browser can load it once and then store it in the cache.

#### CSS splitting

We can split our css files into separate bundle files. That's allow loading application code in parallel 
with styles. In this case, we can as well take advantage of caching. 

#### On demand code splitting

This allows loading chunks that are only needed for the particular use case on programmer request.  
That way we can prioritize resource loading.
For more information check webpack [documention](https://webpack.js.org/guides/code-splitting-async/).

## Code splitting and performance indicators

We need to remember that bundle size can have a significant impact on your application load time.
That's why putting and effort in proper configuration of code splitting is worthwhile.
You can use above features but how you actually check if code splitting configuration works as expected?
Discussion about [Webpack Performance Budgets](https://github.com/webpack/webpack/issues/3216) 
led to adding `performance` configuration object in webpack 2.
Thanks to it we can configure webpack to show code splits that are exceeding expected size limit. 

Performance configuration object allows you to specify what kind of log information during code splitting we 
want to receive after our project is transpiled. There are three properties we can specify 
in 'performance' object: `hints`, `maxEntryPointSize` and `maxAssetSize`. Sample configuration can
look like this:

```
performance: {
  hints: "warning",
  maxEntrypointSize: 300000,
  maxAssetSize: 150000
}
```

By applying above configuration we will receive warning in case if size of our entry 
assets will be above 0.4 megabyte or if any of assets size emitet by webpack exceed 0.15. 
According to webpack documentation for production recommended configuration is `hints:"error"` throw an 
error in case of exceeding set limit.

Given numbers are just example and on [performance budget](http://www.performancebudget.io/) site you can 
check what kind of loading time you expect and base on that it will estimate proper bundle size for your application.
Having that number in your webpack configuration will help you to control size of your code splits
and in consequence avoid performance issues.

I hope that you find this post interesting. We would love to hear your feedback.
